// Generated by CoffeeScript 1.11.1

/*
The nesh command, which parses options and then drops the user
into an interactive session.
 */

(function() {
  var _, argv, config, disabled, enabled, evalArg, evalArgs, evalScript, evalScripts, exec, fs, install, isJs, nesh, optimist, opts, path, prefix, uninstall,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  exec = require('child_process').exec;

  fs = require('fs');

  nesh = require('./nesh');

  path = require('path');

  optimist = require('optimist').usage('$0 [options]').options('b', {
    describe: 'Load Babel for ES6/7 support; shortcut for -l babel',
    boolean: true
  }).options('c', {
    describe: 'Load CoffeeScript; shortcut for -l coffee',
    boolean: true
  }).options('disable', {
    describe: 'Disable plugin(s) for autoload',
    string: true
  }).options('e', {
    alias: 'eval',
    describe: 'Filename or string to eval in the REPL context',
    string: true
  }).options('enable', {
    describe: 'Enable plugin(s) for autoload',
    string: true
  }).options('h', {
    alias: 'help',
    describe: 'Show help and exit',
    boolean: true
  }).options('l', {
    alias: 'lang',
    describe: 'Set interpreter language',
    string: true
  }).options('list-languages', {
    describe: 'List available languages',
    boolean: true
  }).options('p', {
    alias: 'prompt',
    describe: 'Set prompt string',
    string: true
  }).options('plugins', {
    describe: 'List auto-loaded plugins',
    boolean: true
  }).options('v', {
    alias: 'version',
    describe: 'Show version and exit',
    boolean: true
  }).options('verbose', {
    describe: 'Enable verbose debug output',
    boolean: true
  }).options('w', {
    alias: 'welcome',
    describe: 'Set welcome message',
    string: true
  });

  argv = optimist.argv;

  if (argv.h) {
    optimist.showHelp();
    return;
  }

  if (argv.v) {
    nesh.log.info("nesh version " + nesh.version);
    return;
  }

  if (argv['list-languages']) {
    nesh.log.info(nesh.languages().join(', '));
    return;
  }

  if (argv.verbose) {
    nesh.log.level = nesh.log.DEBUG;
  }

  nesh.config.load();

  if (argv.enable) {
    enabled = argv.enable.split(',');
    install = enabled.filter(function(item) {
      return !fs.existsSync("./plugins/" + item + ".js");
    });
    prefix = path.join(nesh.config.home, '.nesh_modules');
    if (install.length) {
      exec("npm --prefix=" + prefix + " --color=always install " + (install.join(' ')) + " 2>&1", function(err, stdout) {
        nesh.log.info(stdout);
        if (err) {
          throw err;
        }
      });
    }
    config = nesh.config.get();
    if (config.plugins == null) {
      config.plugins = [];
    }
    config.plugins = _(config.plugins.concat(enabled)).uniq();
    if (config.pluginsExclude == null) {
      config.pluginsExclude = [];
    }
    config.pluginsExclude = _(config.pluginsExclude).reject(function(item) {
      return indexOf.call(enabled, item) >= 0;
    });
    nesh.config.save();
  }

  if (argv.disable) {
    disabled = argv.disable.split(',');
    prefix = path.join(nesh.config.home, '.nesh_modules');
    uninstall = disabled.filter(function(item) {
      return fs.existsSync(path.join(prefix, 'node_modules', item));
    });
    if (uninstall.length) {
      exec("npm --prefix=" + prefix + " --color=always rm " + (uninstall.join(' ')) + " 2>&1", function(err, stdout) {
        nesh.log.info(stdout);
        if (err) {
          throw err;
        }
      });
    }
    config = nesh.config.get();
    if (config.plugins == null) {
      config.plugins = [];
    }
    config.plugins = _(config.plugins).reject(function(item) {
      return indexOf.call(disabled, item) >= 0;
    });
    if (config.pluginsExclude == null) {
      config.pluginsExclude = [];
    }
    config.pluginsExclude = _(config.pluginsExclude.concat(disabled)).uniq();
    nesh.config.save();
  }

  if (argv.enable || argv.disable) {
    return;
  }

  if (argv.c) {
    argv.lang = 'coffee';
  }

  if (argv.b) {
    argv.lang = 'babel';
  }

  if (argv.lang) {
    nesh.loadLanguage(argv.lang);
  }

  opts = {};

  if (argv.prompt != null) {
    opts.prompt = argv.prompt;
  }

  if (argv.welcome != null) {
    opts.welcome = argv.welcome;
  }

  if (argv["eval"]) {
    evalArgs = argv["eval"] instanceof Array ? argv["eval"] : [argv["eval"]];
    evalScripts = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = evalArgs.length; i < len; i++) {
        evalArg = evalArgs[i];
        isJs = false;
        evalScript = fs.existsSync(evalArg) ? (isJs = evalArg.slice(-3) === '.js', fs.readFileSync(evalArg, 'utf-8')) : evalArg;
        if (!isJs && nesh.compile) {
          nesh.log.debug('Compiling eval data');
          evalScript = nesh.compile(evalScript);
        }
        results.push(evalScript);
      }
      return results;
    })();
    opts.evalData = evalScripts.join(";\n");
  }

  nesh.init(true, function(err) {
    var i, len, plugin, ref;
    if (err) {
      return nesh.log.error(err);
    }
    if (argv.plugins) {
      ref = nesh.plugins;
      for (i = 0, len = ref.length; i < len; i++) {
        plugin = ref[i];
        nesh.log.info((plugin.name + ": ") + ("" + plugin.description).grey);
      }
      return;
    }
    return nesh.start(opts, function(err) {
      if (err) {
        return nesh.log.error(err);
      }
    });
  });

}).call(this);

//# sourceMappingURL=command.js.map
