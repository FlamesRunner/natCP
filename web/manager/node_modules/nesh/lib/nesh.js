// Generated by CoffeeScript 1.11.1

/*
Node Enhanced Interactive Interpreter
=====================================
Provides a simple to use, extensible, embeddable interpreter for
your apps.
 */

(function() {
  var callPluginMethod, fs, initialized, nesh, neshInfo, path, processPlugins, start,
    hasProp = {}.hasOwnProperty;

  fs = require('fs');

  neshInfo = require('../package');

  path = require('path');


  /*
  Process a method call on all loaded plugins. This calls the requested
  method on each plugin in the order they were added, skipping plugins
  which do not have the method defined. If the method is defined and it
  takes two parameters (arg, next) then it is assumed to be async and
  treated as such, otherwise treated as a sync call. Callback is
  passed an error if one occurs during processing.
   */

  processPlugins = function(method, arg, callback) {
    var process;
    if (!nesh.plugins.length) {
      return typeof callback === "function" ? callback() : void 0;
    }
    process = function(i) {
      if (i >= nesh.plugins.length) {
        return typeof callback === "function" ? callback() : void 0;
      }
      if (nesh.plugins[i][method] != null) {
        return callPluginMethod(nesh.plugins[i][method], arg, function(err) {
          if (err) {
            nesh.log.error("Error in plugin " + nesh.plugins[i].name + ":");
            if (err.stack) {
              nesh.log.error(err.stack);
            } else {
              nesh.log.error(err);
            }
          }
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          return process(i + 1);
        });
      } else {
        return process(i + 1);
      }
    };
    return process(0);
  };


  /*
  Call the possibly async method. callback gets passed an error
  object if an error occurs.
   */

  callPluginMethod = function(method, arg, callback) {
    var err;
    if (method.length === 2) {
      return method(arg, callback);
    } else {
      try {
        method(arg);
      } catch (error) {
        err = error;
        return typeof callback === "function" ? callback(err) : void 0;
      }
      return callback();
    }
  };

  start = function(opts, callback) {
    var key, ref, value;
    if (typeof opts === 'function') {
      callback = opts;
    }
    ref = nesh.defaults;
    for (key in ref) {
      if (!hasProp.call(ref, key)) continue;
      value = ref[key];
      if (opts[key] == null) {
        opts[key] = value;
      }
    }
    return processPlugins('preStart', {
      nesh: nesh,
      options: opts
    }, function(err) {
      var repl;
      if (err) {
        return typeof callback === "function" ? callback(err) : void 0;
      }
      repl = nesh.repl.start(opts);
      repl.opts = opts;
      return processPlugins('postStart', {
        nesh: nesh,
        options: opts,
        repl: repl
      }, function(err) {
        if (err) {
          return typeof callback === "function" ? callback(err) : void 0;
        }
        return typeof callback === "function" ? callback(err, repl) : void 0;
      });
    });
  };

  nesh = exports;

  nesh.version = neshInfo.version;

  nesh.defaults = {
    useGlobal: true,
    prompt: 'nesh> '
  };

  nesh.compile = null;

  nesh.repl = require('repl');

  nesh.plugins = [];

  nesh.config = require('./config');

  nesh.log = require('./log');

  nesh.languages = function() {
    return fs.readdirSync(__dirname + "/languages").filter(function(item) {
      return item.slice(-2) === 'js';
    }).map(function(item) {
      return item.split('.').slice(0, -1).join('.');
    });
  };

  nesh.loadLanguage = function(data) {
    switch (typeof data) {
      case 'function':
        return data({
          nesh: nesh
        });
      case 'string':
        return require("./languages/" + data).setup({
          nesh: nesh
        });
      default:
        throw new Error("Data must be a function or string! Received " + data);
    }
  };

  nesh.loadPlugin = function(plugin, callback) {
    var e, name, prefix;
    if (typeof plugin === 'string') {
      name = plugin;
      try {
        plugin = require("./plugins/" + name);
      } catch (error) {
        e = error;
        try {
          prefix = path.join(nesh.config.home, '.nesh_modules', 'node_modules');
          plugin = require(path.join(prefix, name));
        } catch (error) {
          e = error;
          return callback("Could not find plugin '" + name + "': " + e + "!");
        }
      }
      if (plugin.name == null) {
        plugin.name = name;
      }
      if (plugin.description == null) {
        plugin.description = 'No description';
      }
    }
    nesh.plugins.push(plugin);
    if (plugin.setup) {
      return callPluginMethod(plugin.setup, {
        nesh: nesh
      }, callback);
    } else {
      return callback();
    }
  };

  initialized = false;

  nesh.init = function(autoload, callback) {
    if (autoload == null) {
      autoload = true;
    }
    initialized = true;
    if (autoload) {
      return nesh.loadPlugin('autoload', function(err) {
        if (err) {
          return typeof callback === "function" ? callback("[autoload] " + err) : void 0;
        } else {
          return typeof callback === "function" ? callback() : void 0;
        }
      });
    } else {
      return typeof callback === "function" ? callback() : void 0;
    }
  };

  nesh.start = function(opts, callback) {
    if (opts == null) {
      opts = {};
    }
    if (!initialized) {
      return nesh.init(true, function(err) {
        if (err) {
          return typeof callback === "function" ? callback(err) : void 0;
        }
        return start(opts, callback);
      });
    } else {
      return start(opts, callback);
    }
  };

}).call(this);

//# sourceMappingURL=nesh.js.map
